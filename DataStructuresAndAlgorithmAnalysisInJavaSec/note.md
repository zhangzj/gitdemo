## 引论

简要阐述本书的目的和目标；简要复习离散数学和程序设计的一些概念；将会看到的内容

- 看到程序对于合理的大量输入的运行性能和在适量输入下得运行性能的同等重要性

- 需要了解的基本数学基础

- 递归的基本复习

- 需要了解的书中用到的Java语言的特点

### 1.1 本书讨论的内容

排序问题，字母组合问题等等，这些问题的解决方法有很多，相对来讲实现也并不困难，但是当需要解决的问题数量级越来越大，在合理时间内的解决方法就很难实现了；由此得出的一个观念是，简单得出一个解决方案，写出一个可以工作的程序还远远不够，当数量级急剧增长，运行时间将会变成遥遥无期；

在一定的数据集下，怎么估算解决方法的运行时间，不同的解决方案之间的差别和优劣，怎么确定运行时间，并且针对程序的瓶颈进行改进，怎么优化，就是这些问题有待研究

### 1.2 数学知识复习

指数，对数，级数的基本公式和定理；模运算和证明的方法

### 1.3 递归简论

在程序中调用自身即为递归

### 1.4 实现泛型特性构件 pre - Java 5 1.5 利用Java 5 泛型实现泛型特性成分

### 1.6 函数对象

## 2 算法分析

算法是求解问题的具体步骤，指令的集合。首先要保证算法是正确的，能够得出对问题的正确解；接下来就需要确定求解所需要的时间，所消耗的空间资源；这一章需要知道的是

- 如何估计一个程序所需要的时间
- 如何降低一个程序的运行时间
- 递归粗心使用造成的后果
- 一个数自己乘自己得到的幂，以及计算两个数的最大公因数的有效算法

### 2.1 数学基础

计算算法资源消耗是一个理论问题，那就需要正式的数学定义

### 2.2 计算模型

假设一台标准计算机，有简单的指令系统，加减乘除等，完成一个指令计算的时间一定

### 2.3 要分析的问题

第一个要面对的就是运行时间，具体的实现实际上对时间的影响不大，一般分析的是最坏情况下的运行时间，代表一个最低的界限；

首先一个常识，数据量增长和运行时间是正相关的，只是这个曲线的斜率如何就是这个算法的优劣的体现了；在数据很小的时候，可能多个算法都可以在一眨眼完成求解，但是数据慢慢变大，最终有些算法时间依然可接受，但是一些算法就爆炸增长，完全不可接受了

### 2.4 运行时间计算

所有指令的运行时间之和是再明显不过的答案，但是指令运行也有类别，比如循环，嵌套循环，判断控制流，数据变大的时候，那一部分的指令变大也具体分析

方法论：最最实际的方式是，使用不同的算法实现，通过相同的数据进行测试，然后根据数据增长来判断时间的涨幅，就可以比较出来了

## 3 表、栈和队列

三种基本数据结构，每一个有意义的程序都会用到一种数据结构，栈总是被间接用到；

- 介绍抽象数据类型ADT
- 如何有效执行表的操作
- 介绍栈AGT及其在实现递归方面的应用
- 介绍队列ADT及其在操作系统和算法设计中的应用

### 3.1 抽象数据类型ADT

所谓抽象，就是没有任何实现，是一组数学模型的集合，每一个对象都带有一组操作；这里讨论的三个基本ADT是最基本的例子

### 3.2 表ADT List

就是列表，一串数据，没有元素就是空列表，长度为0；除了头尾，每一个元素都有前面一个元素和后面一个元素；具体的操作有的find，insert等等，可以使用数组来实现ListADT

简单链表使用一系列的节点组成，每一个节点存储后面节点的引用；双链表的每一个节点都会存储前后两个节点的地址；

### 3.3 JDK中的list

collection中有一个迭代器，Iterator，最好不要使用for来循环集合，而是使用迭代器

List接口，ArrayList类和LinkedList类；这两个实现在性能和哥哥方面有所差异和优劣，各有用处和适用场景；ArrayList和linkedList的实现需要仔细研究，还有其内部的迭代器遍历的用法和实现

### 3.6 栈 ADT

栈又叫做后进先出表，只能在一个方向进行节点的增加和删除；ArrayList和LinkedList都支持栈操作；可以通过链表实现，也可以通过数组来实现；

### 3.7 队列 ADT

在一端进行插入，另一端进行删除的表；就像一个排好的队伍，对于资源有限的情况，处理上来不及，就是一个等待中的队伍，等待时间最长的节点最先处理，新来的就排在最后；

### 小结

描述了一些ADT，三个基本的，栈，队列和列表，这是计算机中的三个基本数据结构

## 4 树

数据量特别大的时候。链表这种线性访问很慢，不太适合；树， Tree，这里涉及的叫做二叉查找树，binary search tree，JDK中是由两个实现的集合类，TreeSet和TreeMap；

树在一般应用中的使用有；实现几个流行操作系统的文件系统；树用来计算算数表达式的值；支持使用平均时间进行搜索操作；讨论使用实现好的类

### 4.1 预备知识

在一个很多节点和节点之间的关系中，每一个节点都有一个或者零个父节点，只有根节点没有父节点，每一个节点都可以有零个或者多个子节点；

### 树的实现

实现树的一种方法是每一个节点除了存储数据之外还存储一些地址，每一个子节点都有一个地址指向父节点；如果每一个父节点都存储自己所有子节点的地址，那就太浪费了，也不太现实，所以优化的方案就是，父节点只会存储自己的第一个子节点的地址，之后由一个兄弟节点的链表来表示所有的子节点

节点的实现中，除了数据域Object element之外，还有两个域，一二个是自己的第一个子节点，嫡长子，一个是自己的下一个兄弟节点；

### 4.2 二叉树

二叉树比树的概念多了一个规则，就是每一个节点不能有多于两个儿子，也就是每一个节点的子节点数目是0，1，2中的一个，不会更多；

二叉树节点的实现就会简化，除了数据域之外，只要存储两个子节点的地址就可以，分别是左节点和右节点的地址；

### 4.3 查找树ADT 二叉查找树

又加上了一个与数据有关的规则，二叉树的基础上约定，对于每一个节点X，左边子树中所有项的值小于X中的项，右边所有的节点的值，都大于X的值；再往下走的时候，遇到一个节点，根据这个节点的大小，就可以明白是向左还是向右才能更接近想要的数据；

如果数据是一组预先排好序的数据，那么就是不断往树的一侧进行插入，会十分损耗性能，，这个树就会只由那些没有左节点的节点组成；再加上一个约定，平衡，也就是左右平衡，任何节点的深度都不能过深；

### 4.4 AVL树

带有平衡条件的二叉查找树，AVL，Adelson-Velski和Landis树；AVL树，表示一个左子树和右子树的高度最多差1的二叉查找树，空树的高度定义为-1；每一个节点的左子树和右子树的高度最多不差1，只是根节点平衡是不可以的；

插入一个节点后，AVL的平衡可能会遭到破坏，那么就需要调整树的结构来进行修正，重新回到平衡的状态，这种修正称为，旋转，又分为单旋转和双旋转

### 4.5 伸展树

伸展树的意思是，为了防止AVL被访问的时候很多次都是访问很深的节点造成性能灾难，就在一个节点被访问之后，操作旋转，把被访问的节点推到根节点上

### 树的遍历

中序遍历：先访问每一个节点本身，而后是节点的左子树，然后再访问右子树；
后序遍历：先处理子树而后处理节点本身，
先序遍历：当前节点在子节点之前处理
层序遍历：一层层来

### 4.7 B树

到现在为止，树的规模都是可以吧整个数据结构放到内存也没问题的大小，但是如果数据很大，那么久要考虑一下吧数据结构放到外存了；当加入了IO访问的时候，指令执行时间一致的约定也开始变化，不能把所有的访问都看作是使用相同时间的了；

那B树实际上就是加上了指令时间变化的一个约定，因为改变的因素不同了；

一个父节点有几个分叉，那就成为M阶，二叉树就是2阶；阶是M的B树具有以下特性；1. 数据项存储在树叶上；2. 不是叶的节点存储直到M-1个关键字来展示搜索的方向：关键字i表示i+1中的最小的关键字；3. 树的根要么叶节点要么是有2到M之间的子节点存在；4. 除了根节点之外，所有非树叶节点的子节点数都在m/2到m之间；5. 所有的树叶都在相同的深度上，并有L/2到L之间和数据项

B树的用处在于访问磁盘的时候，由于是B树形式存储的数据，所以在访问IO时候有规律可循，改善性能

### 4.8 标准库中的集合与映射

Set和Map的出现是应为ArrayList和LinkedList的查找效率很低；Set表示不允许重复数据的Collection；Map是键值对的集合，关键字必须唯一；

## 5 散列

散列表，哈希表，hash table ADT；散列是一种允许使用常数时间进行插入删除和查找的技术；但是不支持带有排序信息的树操作；接下爱看到实现散列的几种方法，并分析几种方法；散列的应用场景；比较散列表和二叉查找树；

### 5.1 一般想法

理想的散列表是一个包含一些项的具有固定大小的数组；通过散列函数，确定每一个项目应该存放在数组的那个索引中，索引的大小就是0到tablesize-1，接下来的问题就是，如果两个项目的散列函数结果是一样的索引怎么办，这种冲突怎么解决；对于一张散列表，怎么确定他的数组大小？

### 5.2 散列函数

散列函数就是根据key来计算出一个索引整数的函数，如果key是整数那还好，如果是字符串，不同的散列函数效果不同，实际上也就是代表了一种散列算法；结果上来说，对于不同的key，计算出不一样的索引就ok；

### 5.3 分离链接法

如果索引计算出来一样怎么办，第一种方法分离链接法，separate chaining，将散列到同一个值的所有元素保留到一个表中，同一个list；

装填因子；定义为散列表中的元素个数对该表大小的比；概念上就是实际元素和哈希表大小的比，入住率空置率的概念；

### 5.4 不用链表的散列表

分离链表法的缺点是使用一些链表，给新单元分配地址需要时间；第二种方法是当计算出冲突的时候，尝试寻找空的单元；这种散列表一般叫做探测散列表，probing hash table；如何探测空的单元，怎么找到空位？

线性探测法；就是冲突时候向下找，一个个找，找到空的为止；只要表够大就肯定能找到一个空位；但是一直有首次冲突出现的话，就会出现聚集，也就是节点聚集在一个区块，这样子会影响整体的命中

平方探测法；当第一次出现冲突，为了避免线性探测的聚集现象，找下一个单元的时候使用平方而不是线性的方式找位子；还是会出现二次聚集的现象，但是这个再说

双散列；最后一个解决冲突的方法是双散列，double hashing，首次冲突之后的寻找位置再使用一个hash计算位置

### 5.5 再散列

当散列表漫道一半容量的时候，新建一个两倍大的散列表，然后重新散列排布，这样子开销还算能接受

### 5.6 标准库中的散列表

标准库包括Set和Map的散列表实现，也就是HashSet和HashMap类

### 5.7 可扩展散列

数据量太大，主存装不下的时候，就要考虑磁盘IO了；B树

### 小结

散列的常见用途是在游戏中，当程序搜索游戏的不同行，跟踪通过计算基于位置的散列函数而看到的一些位置，并把对于该位置的移动存储起来。通过移动的简单变换来避免昂贵的重复计算，所有游戏程序的这种一般特点叫做变换表，tranposition table

## 6 优先队列 堆

医院挂号排队，总有些人是急病，那优先级就会高一些，先看；优先队列，priority queue：ADT的有效实现，优先队列的使用和高级实现；

### 6.1 模型

插入，很必要的操作；还有一个操作是删除最小的节点，有一个筛选策略来决定该删除哪一个，也许；一个出队，一个入队，只是操作的条件和实现不同；

### 6.1 一些简单的实现

一个是用排序好的链表来实现，一种是使用二叉查找树

### 6.3 二叉堆

使用对于优先队列的实现，二叉堆相当普遍，一般说堆就是说是这个二叉堆了
